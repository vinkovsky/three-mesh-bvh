{"mappings":"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","sources":["example/pathtracing/utils.js","example/pathtracing/ggxSampling.js","example/pathtracing/materialSampling.js","example/cpuPathTracing.js"],"sourcesContent":["import { Vector3 } from 'three';\n\nconst tempVector = new Vector3();\nconst tempVector1 = new Vector3();\nconst tempVector2 = new Vector3();\n\nexport const EPSILON = 1e-7;\n\n// https://docs.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_standard_multisample_quality_levels\nexport const ANTIALIAS_WIDTH = 16;\nexport const ANTIALIAS_OFFSETS = [\n\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ],\n];\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\nexport function schlickFresnel( cosine, f0 ) {\n\n\treturn f0 + ( 1.0 - f0 ) * Math.pow( 1.0 - cosine, 5.0 );\n\n}\n\n// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\nexport function schlickFresnelFromIor( cosine, iorRatio ) {\n\n\t// Schlick approximation\n\tconst r0 = Math.pow( ( 1 - iorRatio ) / ( 1 + iorRatio ), 2 );\n\treturn schlickFresnel( cosine, r0 );\n\n}\n\nexport function refract( dir, norm, iorRatio, target ) {\n\n\t// snell's law\n\t// ior1 * sin( t1 ) = ior2 * sin( t2 )\n\tlet cosTheta = Math.min( - dir.dot( norm ), 1.0 );\n\n\ttempVector\n\t\t.copy( dir )\n\t\t.addScaledVector( norm, cosTheta )\n\t\t.multiplyScalar( iorRatio );\n\n\ttarget\n\t\t.copy( norm )\n\t\t.multiplyScalar( - Math.sqrt( Math.abs( 1.0 - tempVector.lengthSq() ) ) )\n\t\t.add( tempVector );\n\n}\n\n// forms a basis with the normal vector as Z\nexport function getBasisFromNormal( normal, targetMatrix ) {\n\n\tif ( Math.abs( normal.x ) > 0.5 ) {\n\n\t\ttempVector.set( 0, 1, 0 );\n\n\t} else {\n\n\t\ttempVector.set( 1, 0, 0 );\n\n\t}\n\n\ttempVector1.crossVectors( normal, tempVector ).normalize();\n\ttempVector2.crossVectors( normal, tempVector1 ).normalize();\n\ttargetMatrix.makeBasis( tempVector2, tempVector1, normal );\n\n}\n\nexport function getHalfVector( a, b, target ) {\n\n\treturn target.addVectors( a, b ).normalize();\n\n}\n\n// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n// we find a ray like that we ignore it to avoid artifacts.\n// This function returns if the direction is on the same side of both planes.\nexport function isDirectionValid( direction, surfaceNormal, geometryNormal ) {\n\n\tconst aboveSurfaceNormal = direction.dot( surfaceNormal ) > 0;\n\tconst aboveGeometryNormal = direction.dot( geometryNormal ) > 0;\n\treturn aboveSurfaceNormal === aboveGeometryNormal;\n\n}\n","import { Vector3 } from 'three';\n\nconst _V = new Vector3();\nconst _T1 = new Vector3();\nconst _T2 = new Vector3();\nconst _N = new Vector3();\nconst _Z_VECTOR = new Vector3( 0, 0, 1 );\nconst M_PI = Math.PI;\n\n// The GGX functions provide sampling and distribution information for normals as output so\n// in order to get probability of scatter direction the half vector must be computed and provided.\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n// [2] http://jcgt.org/published/0007/04/01/\n// [4] http://jcgt.org/published/0003/02/03/\n\nexport function ggxDirection( incidentDir, roughnessX, roughnessY, random1, random2, target ) {\n\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t// function below, as well\n\n\t// Implementation from reference [1]\n\t// stretch view\n\tconst V = _V.set( roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z ).normalize();\n\n\t// orthonormal basis\n\tconst T1 = ( V.z < 0.9999 ) ? _T1.crossVectors( V, _Z_VECTOR ).normalize() : _T1.set( 1, 0, 0 );\n\tconst T2 = _T2.crossVectors( T1, V );\n\n\t// sample point with polar coordinates (r, phi)\n\tconst a = 1.0 / ( 1.0 + V.z );\n\tconst r = Math.sqrt( random1 );\n\tconst phi = ( random2 < a ) ? random2 / a * M_PI : M_PI + ( random2 - a ) / ( 1.0 - a ) * M_PI;\n\tconst P1 = r * Math.cos( phi );\n\tconst P2 = r * Math.sin( phi ) * ( ( random2 < a ) ? 1.0 : V.z );\n\n\t// compute normal\n\tT1.multiplyScalar( P1 );\n\tT2.multiplyScalar( P2 );\n\tconst N = _N.addVectors( T1, T2 ).addScaledVector( V, Math.sqrt( Math.max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) ) );\n\n\t// unstretch\n\tN.x *= roughnessX;\n\tN.y *= roughnessY;\n\tN.z = Math.max( 0.0, N.z );\n\tN.normalize();\n\n\ttarget.copy( N );\n\n\treturn target;\n\n}\n\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (2) from reference [2]\nfunction ggxLamda( theta, roughness ) {\n\n\tconst tanTheta = Math.tan( theta );\n\tconst tanTheta2 = tanTheta * tanTheta;\n\tconst alpha2 = roughness * roughness;\n\n\tconst numerator = - 1 + Math.sqrt( 1 + alpha2 * tanTheta2 );\n\treturn numerator / 2;\n\n}\n\n// See equation (2) from reference [2]\nexport function ggxShadowMaskG1( theta, roughness ) {\n\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n}\n\n// See equation (125) from reference [4]\nexport function ggxShadowMaskG2( wi, wo, roughness ) {\n\n\tconst incidentTheta = Math.acos( wi.z );\n\tconst scatterTheta = Math.acos( wo.z );\n\treturn 1.0 / ( 1 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n}\n\nexport function ggxDistribution( halfVector, roughness ) {\n\n\t// See equation (33) from reference [0]\n\tconst a2 = roughness * roughness;\n\tconst cosTheta = halfVector.z;\n\tconst cosTheta4 = Math.pow( cosTheta, 4 );\n\n\tif ( cosTheta === 0 ) return 0;\n\n\tconst theta = Math.acos( halfVector.z );\n\tconst tanTheta = Math.tan( theta );\n\tconst tanTheta2 = Math.pow( tanTheta, 2 );\n\n\tconst denom = Math.PI * cosTheta4 * Math.pow( a2 + tanTheta2, 2 );\n\treturn a2 / denom;\n\n\t// See equation (1) from reference [2]\n\t// const { x, y, z } = halfVector;\n\t// const a2 = roughness * roughness;\n\t// const mult = x * x / a2 + y * y / a2 + z * z;\n\t// const mult2 = mult * mult;\n\n\t// return 1.0 / Math.PI * a2 * mult2;\n\n}\n\n// See equation (3) from reference [2]\nexport function ggxPDF( wi, halfVector, roughness ) {\n\n\tconst incidentTheta = Math.acos( wi.z );\n\tconst D = ggxDistribution( halfVector, roughness );\n\tconst G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\treturn D * G1 * Math.max( 0.0, wi.dot( halfVector ) ) / wi.z;\n\n}\n","import { schlickFresnelFromIor, refract, getHalfVector } from './utils.js';\nimport { ggxDirection, ggxPDF, ggxShadowMaskG2, ggxDistribution } from './ggxSampling.js';\nimport { MathUtils, Vector3, Color } from 'three';\n\n// Technically this value should be based on the index of refraction of the given dielectric.\nconst tempDir = new Vector3();\nconst halfVector = new Vector3();\nconst tempColor = new Color();\nconst whiteColor = new Color( 0xffffff );\n\n// diffuse\nfunction diffusePDF( wo, wi, material, hit ) {\n\n\t// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\n\tconst cosValue = wi.z;\n\treturn cosValue / Math.PI;\n\n}\n\nfunction diffuseDirection( wo, hit, material, lightDirection ) {\n\n\tlightDirection.randomDirection();\n\tlightDirection.z += 1;\n\tlightDirection.normalize();\n\n}\n\nfunction diffuseColor( wo, wi, material, hit, colorTarget ) {\n\n\t// TODO: scale by 1 - F here\n\t// note on division by PI\n\t// https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wi.z / Math.PI / Math.PI )\n\t\t.multiplyScalar( 1.0 - transmission );\n\n}\n\n// specular\nfunction specularPDF( wo, wi, material, hit ) {\n\n\t// See equation (17) in http://jcgt.org/published/0003/02/03/\n\tconst filteredRoughness = hit.filteredSurfaceRoughness;\n\tgetHalfVector( wi, wo, halfVector );\n\treturn ggxPDF( wi, halfVector, filteredRoughness ) / ( 4 * wi.dot( halfVector ) );\n\n}\n\nfunction specularDirection( wo, hit, material, lightDirection ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tconst filteredRoughness = hit.filteredSurfaceRoughness;\n\tggxDirection(\n\t\two,\n\t\tfilteredRoughness,\n\t\tfilteredRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\tlightDirection.copy( wo ).reflect( halfVector ).multiplyScalar( - 1 );\n\n}\n\nfunction specularColor( wo, wi, material, hit, colorTarget ) {\n\n\t// if roughness is set to 0 then D === NaN which results in black pixels\n\tconst { metalness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst filteredRoughness = hit.filteredSurfaceRoughness;\n\n\tgetHalfVector( wo, wi, halfVector );\n\tconst iorRatio = frontFace ? 1 / ior : ior;\n\tconst G = ggxShadowMaskG2( wi, wo, filteredRoughness );\n\tconst D = ggxDistribution( halfVector, filteredRoughness );\n\n\tlet F = schlickFresnelFromIor( wi.dot( halfVector ), iorRatio );\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tconst cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1;\n\n\t}\n\n\tcolorTarget\n\t\t.lerpColors( whiteColor, material.color, metalness )\n\t\t.multiplyScalar( G * D / ( 4 * Math.abs( wi.z * wo.z ) ) )\n\t\t.multiplyScalar( MathUtils.lerp( F, 1.0, metalness ) )\n\t\t.multiplyScalar( wi.z ); // scale the light by the direction the light is coming in from\n\n}\n\n/*\n// transmission\nfunction transmissionPDF( wo, wi, material, hit ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? ior : 1 / ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\n\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\t// sample ggx vndf distribution which gives a new normal\n\tggxDirection(\n\t\two,\n\t\tminRoughness,\n\t\tminRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, halfVector, ratio, lightDirection );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\n\t\t.multiplyScalar( transmission );\n\n}\n*/\n\n// TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfunction transmissionPDF( wo, wi, material, hit ) {\n\n\treturn 1.0;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, new Vector3( 0, 0, 1 ), ratio, lightDirection );\n\ttempDir.randomDirection().multiplyScalar( roughness );\n\tlightDirection.add( tempDir );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( 1.0 - metalness )\n\t\t.multiplyScalar( Math.abs( wi.z ) )\n\t\t.multiplyScalar( transmission );\n\n\t// Color is clamped to [0, 1] to make up for incorrect PDF and over sampling\n\tcolorTarget.r = Math.min( colorTarget.r, 1.0 );\n\tcolorTarget.g = Math.min( colorTarget.g, 1.0 );\n\tcolorTarget.b = Math.min( colorTarget.b, 1.0 );\n\n}\n\nexport function bsdfPdf( wo, wi, material, hit ) {\n\n\tconst { ior, metalness, transmission } = material;\n\tconst { frontFace } = hit;\n\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tlet reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tconst cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1;\n\n\t}\n\n\tlet spdf = 0;\n\tlet dpdf = 0;\n\tlet tpdf = 0;\n\n\tif ( wi.z < 0 ) {\n\n\t\ttpdf = transmissionPDF( wo, wi, material, hit );\n\n\t} else {\n\n\t\tspdf = specularPDF( wo, wi, material, hit );\n\t\tdpdf = diffusePDF( wo, wi, material, hit );\n\n\t}\n\n\tconst transSpecularProb = MathUtils.lerp( reflectance, 1.0, metalness );\n\tconst diffSpecularProb = 0.5 + 0.5 * metalness;\n\tconst pdf =\n\t\tspdf * transmission * transSpecularProb\n\t\t+ tpdf * transmission * ( 1.0 - transSpecularProb )\n\t\t+ spdf * ( 1.0 - transmission ) * diffSpecularProb\n\t\t+ dpdf * ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\n\treturn pdf;\n\n}\n\nexport function bsdfColor( wo, wi, material, hit, targetColor ) {\n\n\tif ( wi.z < 0 ) {\n\n\t\ttransmissionColor( wo, wi, material, hit, targetColor );\n\n\t} else {\n\n\t\tdiffuseColor( wo, wi, material, hit, targetColor );\n\t\ttargetColor.multiplyScalar( 1.0 - material.transmission );\n\n\t\tspecularColor( wo, wi, material, hit, tempColor );\n\t\ttargetColor.add( tempColor );\n\n\t}\n\n}\n\nexport function bsdfSample( wo, hit, material, sampleInfo ) {\n\n\tconst lightDirection = sampleInfo.direction;\n\tconst { ior, metalness, transmission } = material;\n\tconst { frontFace } = hit;\n\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tlet reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tconst cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1;\n\n\t}\n\n\tif ( Math.random() < transmission ) {\n\n\t\tconst specularProb = MathUtils.lerp( reflectance, 1.0, metalness );\n\t\tif ( Math.random() < specularProb ) {\n\n\t\t\tspecularDirection( wo, hit, material, lightDirection );\n\n\t\t} else {\n\n\t\t\ttransmissionDirection( wo, hit, material, lightDirection );\n\n\t\t}\n\n\t} else {\n\n\t\tconst specularProb = 0.5 + 0.5 * metalness;\n\t\tif ( Math.random() < specularProb ) {\n\n\t\t\tspecularDirection( wo, hit, material, lightDirection );\n\n\t\t} else {\n\n\t\t\tdiffuseDirection( wo, hit, material, lightDirection );\n\n\t\t}\n\n\t}\n\n\tsampleInfo.pdf = bsdfPdf( wo, lightDirection, material, hit );\n\tbsdfColor( wo, lightDirection, material, hit, sampleInfo.color );\n\n}\n\n","import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { bsdfSample, bsdfColor, bsdfPdf } from './pathtracing/materialSampling.js';\n\nimport { GUI } from 'dat.gui';\nimport {\n\tacceleratedRaycast,\n\tcomputeBoundsTree,\n\tdisposeBoundsTree,\n\tSAH,\n\tCENTER,\n} from '..';\nimport {\n\tGenerateMeshBVHWorker,\n} from '../src/workers/GenerateMeshBVHWorker.js';\nimport { ANTIALIAS_OFFSETS, ANTIALIAS_WIDTH, EPSILON, getBasisFromNormal, isDirectionValid } from './pathtracing/utils.js';\n\nTHREE.Mesh.prototype.raycast = acceleratedRaycast;\nTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\nTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n\nlet scene, camera, renderer, light, clock;\nlet fsQuad, controls;\nlet dataTexture, samples, task, delay, scanLinePercent;\nlet scanLineElement, containerElement, outputContainer;\nlet renderStartTime, computationTime;\nlet mesh, materials, lightMesh, floorMesh;\n\n// constants\nconst DELAY_TIME = 300;\nconst FADE_DELAY = 150;\n\n// reusable fields\nconst triangle = new THREE.Triangle();\nconst normal0 = new THREE.Vector3();\nconst normal1 = new THREE.Vector3();\nconst normal2 = new THREE.Vector3();\nconst barycoord = new THREE.Vector3();\nconst spherical = new THREE.Spherical();\nconst normalBasis = new THREE.Matrix4();\nconst invBasis = new THREE.Matrix4();\nconst localDirection = new THREE.Vector3();\nconst tempColor = new THREE.Color();\nconst tempVector = new THREE.Vector3();\n\nconst models = {};\nconst params = {\n\tmodel: 'Dragon',\n\tresolution: {\n\t\tresolutionScale: 0.5,\n\t\tsmoothImageScaling: false,\n\t\tstretchImage: true,\n\t},\n\tpathTracing: {\n\t\tpause: false,\n\t\tdisplayScanLine: false,\n\t\tantialiasing: true,\n\t\tbounces: 10,\n\t\tfilterGlossyFactor: 0.5,\n\t\tsmoothNormals: true,\n\t\tdirectLightSampling: true,\n\t},\n\tmaterial: {\n\t\tcolor: '#0099ff',\n\t\temissive: '#000000',\n\t\temissiveIntensity: 1,\n\t\troughness: 0.1,\n\t\tmetalness: 0.0,\n\t\tior: 1.8,\n\t\ttransmission: 0.0,\n\t},\n\tfloor: {\n\t\tenable: true,\n\t\tcolor: '#7f7f7f',\n\t\troughness: 0.1,\n\t\tmetalness: 0.1,\n\t\twidth: 10,\n\t\theight: 10,\n\t},\n\tlight: {\n\t\tenable: true,\n\t\tposition: 'Diagonal',\n\t\tintensity: 30.0,\n\t\tcolor: '#ffffff',\n\t\twidth: 1,\n\t\theight: 1,\n\t},\n\tenvironment: {\n\t\tskyMode: 'sky',\n\t\tskyIntensity: 0.025,\n\t}\n};\n\ninit();\nrender();\n\nfunction init() {\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( 0, 1 );\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\n\t// container of the canvas and scan line to be centered\n\tcontainerElement = document.createElement( 'div' );\n\tcontainerElement.style.position = 'absolute';\n\tcontainerElement.style.inset = '0';\n\tcontainerElement.style.margin = 'auto';\n\tcontainerElement.style.zIndex = '-1';\n\tdocument.body.appendChild( containerElement );\n\tcontainerElement.appendChild( renderer.domElement );\n\n\t// scan line element for tracking render progress\n\tscanLineElement = document.createElement( 'div' );\n\tscanLineElement.style.width = '100%';\n\tscanLineElement.style.position = 'absolute';\n\tscanLineElement.style.borderBottom = '1px solid #e91e63';\n\tscanLineElement.style.visibility = 'hidden';\n\tcontainerElement.appendChild( scanLineElement );\n\n\toutputContainer = document.getElementById( 'output' );\n\n\tfsQuad = new FullScreenQuad( new THREE.MeshBasicMaterial() );\n\tfsQuad.material.transparent = true;\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( - 2.5, 1.5, 2.5 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\t// light\n\tlight = new THREE.HemisphereLight( 0xffffff, 0x666666, 1 );\n\tscene.add( light );\n\n\tlightMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 1, 1, 1, 1 ),\n\t\tnew THREE.MeshBasicMaterial( { side: THREE.DoubleSide } ),\n\t);\n\tlightMesh.position.set( 2, 2, 2 );\n\tlightMesh.lookAt( 0, 0, 0 );\n\tscene.add( lightMesh );\n\n\tfloorMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 1, 1, 1, 1 ),\n\t\tnew THREE.MeshStandardMaterial( { side: THREE.DoubleSide } ),\n\t);\n\tfloorMesh.rotation.x = - Math.PI / 2;\n\tfloorMesh.scale.setScalar( 1 );\n\tfloorMesh.material.ior = 1.6;\n\tfloorMesh.material.transmission = 0;\n\tscene.add( floorMesh );\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcontrols.addEventListener( 'change', resetImage );\n\n\twindow.addEventListener( 'resize', onResize, false );\n\tonResize();\n\n\t// Load sphere\n\tmodels[ 'Sphere' ] = null;\n\t{\n\n\t\tconst sphereMesh = new THREE.Mesh(\n\t\t\tnew THREE.SphereBufferGeometry( 1, 100, 50 ),\n\t\t\tnew THREE.MeshStandardMaterial(),\n\t\t);\n\n\t\tconst { geometry, materials } = mergeMeshes( [ sphereMesh ], true );\n\t\tconst merged = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\tscene.add( merged );\n\n\t\tgeometry.computeBoundsTree( { strategy: SAH, maxLeafTris: 1 } );\n\t\tmodels[ 'Sphere' ] = { mesh: merged, materials, floorHeight: - 1 };\n\n\t}\n\n\tmodels[ 'Cornell Box' ] = null;\n\t{\n\n\t\tconst planeGeom = new THREE.PlaneBufferGeometry( 1, 1, 1, 1 );\n\t\tconst leftWall = new THREE.Mesh(\n\t\t\tplaneGeom,\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0x00ee00,\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t} )\n\t\t);\n\t\tleftWall.rotation.y = Math.PI / 2;\n\t\tleftWall.position.x = - 2;\n\t\tleftWall.scale.setScalar( 4 );\n\t\tleftWall.updateMatrixWorld( true );\n\n\t\tconst rightWall = new THREE.Mesh(\n\t\t\tplaneGeom,\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0xee0000,\n\t\t\t} ),\n\t\t);\n\t\trightWall.rotation.y = Math.PI / 2;\n\t\trightWall.position.x = 2;\n\t\trightWall.scale.setScalar( 4 );\n\t\trightWall.updateMatrixWorld( true );\n\n\t\tconst backWall = new THREE.Mesh(\n\t\t\tplaneGeom,\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0xeeeeee,\n\t\t\t} ),\n\t\t);\n\t\tbackWall.position.z = - 2;\n\t\tbackWall.scale.setScalar( 4 );\n\t\tbackWall.updateMatrixWorld( true );\n\n\t\tconst ceiling = new THREE.Mesh(\n\t\t\tplaneGeom.clone(),\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0xeeeeee,\n\t\t\t} ),\n\t\t);\n\t\tceiling.rotation.x = Math.PI / 2;\n\t\tceiling.position.y = 2;\n\t\tceiling.scale.setScalar( 4 );\n\t\tceiling.updateMatrixWorld( true );\n\n\t\tconst box = new THREE.Mesh(\n\t\t\tnew THREE.BoxBufferGeometry( 1, 2, 1 ),\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t} ),\n\t\t);\n\t\tbox.position.y = - 1.0;\n\t\tbox.position.x = - 0.6;\n\t\tbox.position.z = - 0.25;\n\t\tbox.rotation.y = Math.PI / 4;\n\n\t\tconst box2 = new THREE.Mesh(\n\t\t\tnew THREE.BoxBufferGeometry( 1, 1, 1 ),\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t} ),\n\t\t);\n\t\tbox2.position.y = - 1.5;\n\t\tbox2.position.x = 0.75;\n\t\tbox2.position.z = 0.5;\n\t\tbox2.rotation.y = - Math.PI / 8;\n\n\t\tconst { geometry, materials } = mergeMeshes( [ box, box2, leftWall, rightWall, backWall, ceiling ], true );\n\t\tconst merged = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\tscene.add( merged );\n\n\t\tgeometry.computeBoundsTree( { strategy: SAH, maxLeafTris: 1 } );\n\t\tmodels[ 'Cornell Box' ] = { mesh: merged, materials, floorHeight: - 2 };\n\n\t}\n\n\t// Load dragon\n\tmodels[ 'Dragon' ] = null;\n\tnew GLTFLoader().load( '../models/DragonAttenuation.glb', gltf => {\n\n\t\tlet mesh;\n\t\tgltf.scene.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.name === 'Dragon' ) {\n\n\t\t\t\tmesh = c;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmesh.material = new THREE.MeshStandardMaterial();\n\t\tmesh.geometry.center().scale( 0.25, 0.25, 0.25 ).rotateX( Math.PI / 2 );\n\t\tmesh.position.set( 0, 0, 0 );\n\t\tmesh.scale.set( 1, 1, 1 );\n\t\tmesh.quaternion.identity();\n\n\t\tconst { geometry, materials } = mergeMeshes( [ mesh ], true );\n\t\tconst merged = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\tconst generator = new GenerateMeshBVHWorker();\n\t\tgenerator\n\t\t\t.generate( geometry, { maxLeafTris: 1, strategy: SAH } )\n\t\t\t.then( bvh => {\n\n\t\t\t\tmodels[ 'Dragon' ] = { mesh: merged, materials, floorHeight: mesh.geometry.boundingBox.min.y };\n\t\t\t\tgeometry.boundsTree = bvh;\n\t\t\t\tgenerator.terminate();\n\t\t\t\tscene.add( merged );\n\n\t\t\t} );\n\n\t} );\n\n\tmodels[ 'Engine' ] = null;\n\tnew GLTFLoader().setMeshoptDecoder( MeshoptDecoder ).load( '../models/internal_combustion_engine/model.gltf', gltf => {\n\n\t\tconst originalMesh = gltf.scene.children[ 0 ];\n\t\tconst originalGeometry = originalMesh.geometry;\n\t\tconst newGeometry = new THREE.BufferGeometry();\n\n\t\tconst ogPosAttr = originalGeometry.attributes.position;\n\t\tconst ogNormAttr = originalGeometry.attributes.normal;\n\t\tconst posAttr = new THREE.BufferAttribute( new Float32Array( ogPosAttr.count * 3 ), 3, false );\n\t\tconst normAttr = new THREE.BufferAttribute( new Float32Array( ogNormAttr.count * 3 ), 3, false );\n\n\t\tconst vec = new THREE.Vector3();\n\t\tfor ( let i = 0, l = ogPosAttr.count; i < l; i ++ ) {\n\n\t\t\tvec.fromBufferAttribute( ogPosAttr, i );\n\t\t\tposAttr.setXYZ( i, vec.x, vec.y, vec.z );\n\n\t\t\tvec.fromBufferAttribute( ogNormAttr, i );\n\t\t\tvec.multiplyScalar( 1 / 127 );\n\t\t\tnormAttr.setXYZ( i, vec.x, vec.y, vec.z );\n\n\t\t}\n\n\t\toriginalMesh.scale.multiplyScalar( 5 );\n\t\toriginalMesh.updateMatrixWorld();\n\t\tnewGeometry.setAttribute( 'position', posAttr );\n\t\tnewGeometry.setAttribute( 'normal', normAttr );\n\t\tnewGeometry.setAttribute( 'materialIndex', new THREE.BufferAttribute( new Uint8Array( posAttr.count ), 1, false ) );\n\t\tnewGeometry.setIndex( originalGeometry.index );\n\t\tnewGeometry.applyMatrix4( originalMesh.matrixWorld ).center();\n\t\tnewGeometry.computeBoundingBox();\n\n\t\tconst mesh = new THREE.Mesh( newGeometry, new THREE.MeshStandardMaterial() );\n\t\tconst generator = new GenerateMeshBVHWorker();\n\t\tgenerator\n\t\t\t.generate( newGeometry, { maxLeafTris: 1, strategy: CENTER } )\n\t\t\t.then( bvh => {\n\n\t\t\t\tmodels[ 'Engine' ] = {\n\t\t\t\t\tmesh,\n\t\t\t\t\tmaterials: [ new THREE.MeshStandardMaterial() ],\n\t\t\t\t\tfloorHeight: newGeometry.boundingBox.min.y,\n\t\t\t\t};\n\t\t\t\tnewGeometry.boundsTree = bvh;\n\t\t\t\tgenerator.terminate();\n\n\t\t\t\tscene.add( mesh );\n\n\t\t\t} );\n\n\t} );\n\n\tsamples = 0;\n\tclock = new THREE.Clock();\n\n\tconst gui = new GUI();\n\tgui.add( params, 'model', Object.keys( models ) ).onChange( resetImage );\n\n\tconst resolutionFolder = gui.addFolder( 'resolution' );\n\tresolutionFolder.add( params.resolution, 'resolutionScale', 0.1, 1, 0.01 ).onChange( onResize );\n\tresolutionFolder.add( params.resolution, 'smoothImageScaling' ).onChange( onResize );\n\tresolutionFolder.add( params.resolution, 'stretchImage' ).onChange( onResize );\n\tresolutionFolder.open();\n\n\tconst pathTracingFolder = gui.addFolder( 'path tracing' );\n\tpathTracingFolder.add( params.pathTracing, 'pause' );\n\tpathTracingFolder.add( params.pathTracing, 'displayScanLine' ).onChange( v => {\n\n\t\tscanLineElement.style.visibility = v ? 'visible' : 'hidden';\n\n\t} );\n\tpathTracingFolder.add( params.pathTracing, 'antialiasing' ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'directLightSampling' ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'smoothNormals' ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'bounces', 1, 50, 1 ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'filterGlossyFactor', 0, 1, 0.001 ).onChange( resetImage );\n\tpathTracingFolder.open();\n\n\tconst materialFolder = gui.addFolder( 'model' );\n\tmaterialFolder.addColor( params.material, 'color' ).onChange( resetImage );\n\tmaterialFolder.addColor( params.material, 'emissive' ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'emissiveIntensity', 0, 5, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'roughness', 0, 1.0, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'metalness', 0, 1.0, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'transmission', 0, 1.0, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'ior', 1.0, 2.5, 0.001 ).onChange( resetImage );\n\tmaterialFolder.open();\n\n\tconst floorFolder = gui.addFolder( 'floor' );\n\tfloorFolder.add( params.floor, 'enable' ).onChange( resetImage );\n\tfloorFolder.addColor( params.floor, 'color' ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'roughness', 0, 1, 0.001 ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'metalness', 0, 1, 0.001 ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'width', 3, 20, 0.001 ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'height', 3, 20, 0.001 ).onChange( resetImage );\n\n\tconst lightFolder = gui.addFolder( 'light' );\n\tlightFolder.add( params.light, 'enable' ).onChange( resetImage );\n\tlightFolder.addColor( params.light, 'color' ).onChange( resetImage );\n\tlightFolder.add( params.light, 'intensity', 0, 100, 0.001 ).onChange( resetImage );\n\tlightFolder.add( params.light, 'width', 0, 5, 0.001 ).onChange( resetImage );\n\tlightFolder.add( params.light, 'height', 0, 5, 0.001 ).onChange( resetImage );\n\tlightFolder.add( params.light, 'position', [ 'Diagonal', 'Above', 'Below' ] ).onChange( resetImage );\n\n\tconst envFolder = gui.addFolder( 'environment' );\n\tenvFolder.add( params.environment, 'skyMode', [ 'sky', 'sun', 'checkerboard' ] ).onChange( resetImage );\n\tenvFolder.add( params.environment, 'skyIntensity', 0, 5, 0.001 ).onChange( resetImage );\n\n\tonResize();\n\n}\n\n// Merges meshes into a single geometry, returns a series of materials and geometry with a vertex attribute buffer\n// containing information about the material index to use\nfunction mergeMeshes( meshes, cloneGeometry = true ) {\n\n\tconst transformedGeometry = [];\n\tconst materials = [];\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\tconst mesh = meshes[ i ];\n\t\tconst originalGeometry = meshes[ i ].geometry;\n\t\tconst geom = cloneGeometry ? originalGeometry.clone() : cloneGeometry;\n\t\tmesh.updateMatrixWorld();\n\t\tgeom.applyMatrix4( mesh.matrixWorld );\n\n\t\tconst vertexCount = geom.attributes.position.count;\n\t\tconst materialIndexArray = new Uint8Array( vertexCount ).fill( i );\n\t\tgeom.setAttribute( 'materialIndex', new THREE.BufferAttribute( materialIndexArray, 1, false ) );\n\n\t\ttransformedGeometry.push( geom );\n\t\tmaterials.push( mesh.material );\n\n\t}\n\n\tconst geometry = BufferGeometryUtils.mergeBufferGeometries( transformedGeometry, false );\n\treturn { geometry, materials };\n\n}\n\nfunction onResize() {\n\n\tfunction resizeDataTexture( w, h ) {\n\n\t\tif ( ! dataTexture || dataTexture.image.width !== w || dataTexture.image.height !== h ) {\n\n\t\t\tif ( dataTexture ) {\n\n\t\t\t\tdataTexture.dispose();\n\n\t\t\t}\n\n\t\t\tdataTexture = new THREE.DataTexture( new Float32Array( w * h * 4 ), w, h, THREE.RGBAFormat, THREE.FloatType );\n\t\t\tresetImage();\n\n\t\t}\n\n\t}\n\n\tcamera.aspect = window.innerWidth / window.innerHeight;\n\tcamera.updateProjectionMatrix();\n\n\t// compute the new resolution based on the use parameters\n\tconst dpr = window.devicePixelRatio;\n\tconst resolutionScale = params.resolution.resolutionScale;\n\tif ( params.resolution.stretchImage ) {\n\n\t\tcontainerElement.style.width = `${ window.innerWidth }px`;\n\t\tcontainerElement.style.height = `${ window.innerHeight }px`;\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\trenderer.setPixelRatio( dpr * resolutionScale );\n\t\tresizeDataTexture(\n\t\t\tMath.floor( window.innerWidth * dpr * resolutionScale ),\n\t\t\tMath.floor( window.innerHeight * dpr * resolutionScale ),\n\t\t);\n\n\t} else {\n\n\t\tcontainerElement.style.width = `${ window.innerWidth * resolutionScale }px`;\n\t\tcontainerElement.style.height = `${ window.innerHeight * resolutionScale }px`;\n\t\trenderer.setSize(\n\t\t\tMath.floor( window.innerWidth * resolutionScale ),\n\t\t\tMath.floor( window.innerHeight * resolutionScale )\n\t\t);\n\t\trenderer.setPixelRatio( dpr );\n\t\tresizeDataTexture(\n\t\t\tMath.floor( window.innerWidth * dpr * resolutionScale ),\n\t\t\tMath.floor( window.innerHeight * dpr * resolutionScale ),\n\t\t);\n\n\t}\n\n\trenderer.domElement.style.imageRendering = params.resolution.smoothImageScaling ? 'auto' : 'pixelated';\n\n}\n\nfunction resetImage() {\n\n\t// clear the draw buffer and restart the path tracing loop\n\tdataTexture.image.data.fill( 0 );\n\tdataTexture.needsUpdate = true;\n\tsamples = 0;\n\ttask = runPathTracingLoop();\n\tdelay = 0;\n\tscanLineElement.style.visibility = 'hidden';\n\tscanLinePercent = 100;\n\n\tlightMesh.scale.set( params.light.width, params.light.height, 1 );\n\tlightMesh.material.color.set( params.light.color ).multiplyScalar( params.light.intensity );\n\tlightMesh.visible = params.light.enable;\n\n\tfloorMesh.scale.set( params.floor.width, params.floor.height, 1 );\n\tfloorMesh.material.color.set( params.floor.color );\n\tfloorMesh.material.roughness = Math.pow( params.floor.roughness, 2.0 ); // perceptual roughness\n\tfloorMesh.material.metalness = params.floor.metalness;\n\tfloorMesh.visible = params.floor.enable;\n\n}\n\nfunction* runPathTracingLoop() {\n\n\t// extract options\n\tconst { width, height, data } = dataTexture.image;\n\tconst bounces = parseInt( params.pathTracing.bounces );\n\tconst skyIntensity = parseFloat( params.environment.skyIntensity );\n\tconst skyMode = params.environment.skyMode;\n\tconst smoothNormals = params.pathTracing.smoothNormals;\n\n\t// reusable variables\n\tconst radianceColor = new THREE.Color();\n\tconst throughputColor = new THREE.Color();\n\tconst halfVector = new THREE.Vector3();\n\tconst normal = new THREE.Vector3();\n\tconst ssPoint = new THREE.Vector2();\n\tconst rayStack = new Array( bounces ).fill().map( () => new THREE.Ray() );\n\tconst lightForward = new THREE.Vector3( 0, 0, 1 ).transformDirection( lightMesh.matrixWorld );\n\tconst lightWidth = lightMesh.scale.x;\n\tconst lightHeight = lightMesh.scale.y;\n\tconst raycaster = new THREE.Raycaster();\n\traycaster.firstHitOnly = true;\n\n\tconst seedRay = new THREE.Ray();\n\tconst sampleInfo = {\n\t\tpdf: 0,\n\t\tcolor: new THREE.Color(),\n\t\tdirection: new THREE.Vector3(),\n\t};\n\n\t// initialization of progress variables\n\tlet lastStartTime = performance.now();\n\trenderStartTime = performance.now();\n\tcomputationTime = 0;\n\tscanLinePercent = 100;\n\tscanLineElement.style.visibility = params.pathTracing.displayScanLine ? 'visible' : 'hidden';\n\n\t// ensure the materials are all set to double side for transmissive rendering\n\tmesh.material.side = THREE.DoubleSide;\n\tmaterials.forEach( material => {\n\n\t\tmaterial.side = THREE.DoubleSide;\n\n\t} );\n\n\twhile ( true ) {\n\n\t\tlet randomOffsetX = 0;\n\t\tlet randomOffsetY = 0;\n\t\tif ( params.pathTracing.antialiasing ) {\n\n\t\t\tconst antiAliasIndex = ( samples ) % ANTIALIAS_OFFSETS.length;\n\t\t\t[ randomOffsetX, randomOffsetY ] = ANTIALIAS_OFFSETS[ antiAliasIndex ];\n\t\t\trandomOffsetX = ( randomOffsetX / ANTIALIAS_WIDTH ) / width;\n\t\t\trandomOffsetY = ( randomOffsetY / ANTIALIAS_WIDTH ) / height;\n\n\t\t}\n\n\t\tfor ( let y = height - 1; y >= 0; y -- ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t// get the camera ray\n\t\t\t\tssPoint.set( randomOffsetX + x / ( width - 1 ), randomOffsetY + y / ( height - 1 ) );\n\t\t\t\traycaster.setFromCamera( { x: ssPoint.x * 2 - 1, y: ssPoint.y * 2 - 1 }, camera );\n\n\t\t\t\t// get the camera look direction\n\t\t\t\ttempVector.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t\t// copy the ray to the starting ray to pass into the pathTrace function and adjust it\n\t\t\t\t// so ti starts at the camera near clip plane\n\t\t\t\tseedRay.direction.copy( raycaster.ray.direction );\n\t\t\t\tseedRay.origin\n\t\t\t\t\t.copy( raycaster.ray.origin )\n\t\t\t\t\t.addScaledVector( raycaster.ray.direction, camera.near / raycaster.ray.direction.dot( tempVector ) );\n\n\t\t\t\t// run the path trace\n\t\t\t\tradianceColor.set( 0 );\n\t\t\t\tpathTrace( seedRay, radianceColor );\n\n\t\t\t\t// accumulate a rolling average color into the data texture\n\t\t\t\tconst index = ( y * width + x ) * 4;\n\t\t\t\tconst r = data[ index + 0 ];\n\t\t\t\tconst g = data[ index + 1 ];\n\t\t\t\tconst b = data[ index + 2 ];\n\t\t\t\tdata[ index + 0 ] += ( radianceColor.r - r ) / ( samples + 1 );\n\t\t\t\tdata[ index + 1 ] += ( radianceColor.g - g ) / ( samples + 1 );\n\t\t\t\tdata[ index + 2 ] += ( radianceColor.b - b ) / ( samples + 1 );\n\t\t\t\tdata[ index + 3 ] = 1.0;\n\n\t\t\t\t// if we've rendered for ~16ms then wait for the next tick\n\t\t\t\tconst delta = performance.now() - lastStartTime;\n\t\t\t\tif ( delta > 16 ) {\n\n\t\t\t\t\tcomputationTime += delta;\n\t\t\t\t\tscanLinePercent = 100 * y / height;\n\n\t\t\t\t\tyield;\n\t\t\t\t\tlastStartTime = performance.now();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tsamples ++;\n\n\t}\n\n\t// extract other necessary information from the hit\n\tfunction expandHitInformation( hit, ray, accumulatedRoughness ) {\n\n\t\tconst object = hit.object;\n\t\tconst posAttr = object.geometry.attributes.position;\n\t\tconst normalAttr = object.geometry.attributes.normal;\n\t\tconst materialAttr = object.geometry.attributes.materialIndex;\n\n\t\tconst face = hit.face;\n\t\tconst geometryNormal = hit.face.normal;\n\t\tif ( smoothNormals ) {\n\n\t\t\tconst point = hit.point;\n\t\t\ttriangle.a.fromBufferAttribute( posAttr, face.a );\n\t\t\ttriangle.b.fromBufferAttribute( posAttr, face.b );\n\t\t\ttriangle.c.fromBufferAttribute( posAttr, face.c );\n\n\t\t\tnormal0.fromBufferAttribute( normalAttr, face.a );\n\t\t\tnormal1.fromBufferAttribute( normalAttr, face.b );\n\t\t\tnormal2.fromBufferAttribute( normalAttr, face.c );\n\n\t\t\ttriangle.getBarycoord( point, barycoord );\n\n\t\t\tnormal\n\t\t\t\t.setScalar( 0 )\n\t\t\t\t.addScaledVector( normal0, barycoord.x )\n\t\t\t\t.addScaledVector( normal1, barycoord.y )\n\t\t\t\t.addScaledVector( normal2, barycoord.z )\n\t\t\t\t.normalize();\n\n\t\t} else {\n\n\t\t\tnormal.copy( geometryNormal );\n\n\t\t}\n\n\t\tgeometryNormal.transformDirection( object.matrixWorld );\n\t\tnormal.transformDirection( object.matrixWorld );\n\n\t\tconst hitFrontFace = geometryNormal.dot( ray.direction ) < 0;\n\t\tif ( ! hitFrontFace ) {\n\n\t\t\tnormal.multiplyScalar( - 1 );\n\t\t\tgeometryNormal.multiplyScalar( - 1 );\n\n\t\t}\n\n\t\tlet material = object.material;\n\t\tif ( materialAttr ) {\n\n\t\t\tconst materialIndex = materialAttr.getX( face.a );\n\t\t\tmaterial = materials[ materialIndex ];\n\n\t\t}\n\n\t\thit.material = material;\n\t\thit.normal = normal;\n\t\thit.geometryNormal = geometryNormal;\n\t\thit.frontFace = hitFrontFace;\n\n\t\t// compute the filtered roughness value to use during specular reflection computations. A minimum\n\t\t// value of 1e-6 is needed because the GGX functions do not work with a roughness value of 0 and\n\t\t// the accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\thit.filteredSurfaceRoughness = Math.min(\n\t\t\tMath.max(\n\t\t\t\t1e-6,\n\t\t\t\tmaterial.roughness,\n\t\t\t\taccumulatedRoughness * params.pathTracing.filterGlossyFactor * 5.0,\n\t\t\t),\n\t\t\t1.0,\n\t\t);\n\n\n\t}\n\n\t// trace a path starting at the given ray\n\tfunction pathTrace( ray, targetColor ) {\n\n\t\tlet currentRay = ray;\n\t\tlet lastPdf = 0;\n\t\tlet accumulatedRoughness = 0;\n\t\tthroughputColor.set( 0xffffff );\n\t\tfor ( let i = 0; i < bounces; i ++ ) {\n\n\t\t\t// get the ray intersection\n\t\t\tlet hit = null;\n\t\t\traycaster.ray.copy( currentRay );\n\n\t\t\tconst objects = [ mesh ];\n\t\t\tif ( params.light.enable ) {\n\n\t\t\t\tobjects.push( lightMesh );\n\n\t\t\t}\n\n\t\t\tif ( params.floor.enable ) {\n\n\t\t\t\tobjects.push( floorMesh );\n\n\t\t\t}\n\n\t\t\thit = raycaster.intersectObjects( objects, true )[ 0 ];\n\n\t\t\t// check if we hit the light or the model\n\t\t\tif ( hit ) {\n\n\t\t\t\tif ( hit.object === lightMesh ) {\n\n\t\t\t\t\t// only add light on one side\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tconst lightColor = lightMesh.material.color;\n\t\t\t\t\t\ttargetColor.r = Math.min( lightColor.r, 1.0 );\n\t\t\t\t\t\ttargetColor.g = Math.min( lightColor.g, 1.0 );\n\t\t\t\t\t\ttargetColor.b = Math.min( lightColor.b, 1.0 );\n\n\t\t\t\t\t} else if ( currentRay.direction.dot( lightForward ) < 0 ) {\n\n\t\t\t\t\t\t// only add light on one side\n\t\t\t\t\t\tconst lightDistSq = hit.distance * hit.distance;\n\t\t\t\t\t\tconst lightArea = lightWidth * lightHeight;\n\t\t\t\t\t\tconst lightPdf = lightDistSq / ( lightArea * - currentRay.direction.dot( lightForward ) );\n\n\t\t\t\t\t\tconst weight = lastPdf / ( lastPdf + lightPdf );\n\t\t\t\t\t\ttargetColor.r += weight * throughputColor.r * lightMesh.material.color.r;\n\t\t\t\t\t\ttargetColor.g += weight * throughputColor.g * lightMesh.material.color.g;\n\t\t\t\t\t\ttargetColor.b += weight * throughputColor.b * lightMesh.material.color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\n\t\t\t\t\texpandHitInformation( hit, currentRay, accumulatedRoughness );\n\t\t\t\t\tconst { material } = hit;\n\t\t\t\t\tconst nextRay = rayStack[ i ];\n\n\t\t\t\t\t// get the local normal frame\n\t\t\t\t\tgetBasisFromNormal( hit.normal, normalBasis );\n\t\t\t\t\tinvBasis.copy( normalBasis ).invert();\n\n\t\t\t\t\t/* Direct Light Sampling */\n\t\t\t\t\tif ( params.light.enable ) {\n\n\t\t\t\t\t\t// get a random point on the surface of the light\n\t\t\t\t\t\ttempVector\n\t\t\t\t\t\t\t.set( Math.random() - 0.5, Math.random() - 0.5, 0 )\n\t\t\t\t\t\t\t.applyMatrix4( lightMesh.matrixWorld );\n\n\t\t\t\t\t\t// get a ray to the light point\n\t\t\t\t\t\t// note that the ray always starts on the front side of the face implying that transmissive\n\t\t\t\t\t\t// contributions are not included here.\n\t\t\t\t\t\tnextRay.origin.copy( hit.point ).addScaledVector( hit.geometryNormal, EPSILON );\n\t\t\t\t\t\tnextRay.direction.subVectors( tempVector, nextRay.origin ).normalize();\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnextRay.direction.dot( lightForward ) < 0\n\t\t\t\t\t\t\t&& isDirectionValid( nextRay.direction, hit.normal, hit.geometryNormal )\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t// compute the probability of hitting the light on the hemisphere\n\t\t\t\t\t\t\tconst lightArea = lightWidth * lightHeight;\n\t\t\t\t\t\t\tconst lightDistSq = nextRay.origin.distanceToSquared( tempVector );\n\t\t\t\t\t\t\tconst lightPdf = lightDistSq / ( lightArea * - nextRay.direction.dot( lightForward ) );\n\n\t\t\t\t\t\t\traycaster.ray.copy( nextRay );\n\t\t\t\t\t\t\tconst shadowHit = raycaster.intersectObjects( objects, true )[ 0 ];\n\t\t\t\t\t\t\tif ( shadowHit && shadowHit.object === lightMesh ) {\n\n\t\t\t\t\t\t\t\t// get the incoming and outgoing directions in the normal frame\n\t\t\t\t\t\t\t\tlocalDirection.copy( currentRay.direction ).applyMatrix4( invBasis ).multiplyScalar( - 1 ).normalize();\n\t\t\t\t\t\t\t\ttempVector.copy( nextRay.direction ).applyMatrix4( invBasis ).normalize();\n\t\t\t\t\t\t\t\tlocalDirection.normalize();\n\n\t\t\t\t\t\t\t\t// get the material color and pdf\n\t\t\t\t\t\t\t\tbsdfColor( localDirection, tempVector, material, hit, tempColor );\n\n\t\t\t\t\t\t\t\t// add light contribution to the final color\n\t\t\t\t\t\t\t\tconst materialPdf = bsdfPdf( localDirection, tempVector, material, hit );\n\t\t\t\t\t\t\t\tconst misWeight = lightPdf / ( materialPdf + lightPdf );\n\t\t\t\t\t\t\t\ttargetColor.r += lightMesh.material.color.r * throughputColor.r * tempColor.r * misWeight / lightPdf;\n\t\t\t\t\t\t\t\ttargetColor.g += lightMesh.material.color.g * throughputColor.g * tempColor.g * misWeight / lightPdf;\n\t\t\t\t\t\t\t\ttargetColor.b += lightMesh.material.color.b * throughputColor.b * tempColor.b * misWeight / lightPdf;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/* BSDF Sampling */\n\t\t\t\t\t// compute the outgoing vector (towards the camera) to feed into the bsdf to get the\n\t\t\t\t\t// incident light vector.\n\t\t\t\t\tlocalDirection.copy( currentRay.direction ).applyMatrix4( invBasis )\n\t\t\t\t\t\t.multiplyScalar( - 1 ).normalize();\n\n\t\t\t\t\t// sample the surface to get the pdf, reflected color, and direction\n\t\t\t\t\tbsdfSample( localDirection, hit, material, sampleInfo );\n\n\t\t\t\t\t// accumulate a roughness based on the sin of the half vector with the surface normal which\n\t\t\t\t\t// can be used with subsequent ray bounces to avoid fireflies similar to Blender functionality\n\t\t\t\t\thalfVector.addVectors( localDirection, sampleInfo.direction ).normalize();\n\t\t\t\t\taccumulatedRoughness += Math.sin( Math.acos( halfVector.z ) );\n\n\t\t\t\t\t// transform ray back to world frame and offset from surface\n\t\t\t\t\tnextRay.direction.copy( sampleInfo.direction ).applyMatrix4( normalBasis ).normalize();\n\n\t\t\t\t\tconst isBelowSurface = nextRay.direction.dot( hit.geometryNormal ) < 0;\n\t\t\t\t\tnextRay.origin.copy( hit.point )\n\t\t\t\t\t\t.addScaledVector( hit.geometryNormal, isBelowSurface ? - EPSILON : EPSILON );\n\n\t\t\t\t\t// emission contribution\n\t\t\t\t\tconst { emissive, emissiveIntensity } = material;\n\t\t\t\t\ttargetColor.r += ( emissiveIntensity * emissive.r * throughputColor.r );\n\t\t\t\t\ttargetColor.g += ( emissiveIntensity * emissive.g * throughputColor.g );\n\t\t\t\t\ttargetColor.b += ( emissiveIntensity * emissive.b * throughputColor.b );\n\n\t\t\t\t\t// If our PDF indicates there's a less than 0 probability of sampling this new direction then\n\t\t\t\t\t// don't include it in our sampling and terminate the ray modeling that the ray has been absorbed.\n\t\t\t\t\tif (\n\t\t\t\t\t\tsampleInfo.pdf <= 0\n\t\t\t\t\t\t|| ! isDirectionValid( nextRay.direction, hit.normal, hit.geometryNormal )\n\t\t\t\t\t) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsampleInfo.color.multiplyScalar( 1 / sampleInfo.pdf );\n\t\t\t\t\tthroughputColor.multiply( sampleInfo.color );\n\t\t\t\t\tcurrentRay = nextRay;\n\t\t\t\t\tlastPdf = sampleInfo.pdf;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: is this contribution supposed to be weighted with multiple importance sampling, as well?\n\t\t\t\tsampleSkyBox( currentRay.direction, tempColor );\n\t\t\t\ttempColor.multiply( throughputColor );\n\t\t\t\ttargetColor.add( tempColor );\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// sample the skybox in the given direction and put the sampled color into \"target\"\n\tfunction sampleSkyBox( direction, target ) {\n\n\t\tif ( skyMode === 'checkerboard' ) {\n\n\t\t\tspherical.setFromVector3( direction );\n\n\t\t\tconst angleStep = Math.PI / 10;\n\t\t\tconst thetaEven = Math.floor( spherical.theta / angleStep ) % 2 === 0;\n\t\t\tconst phiEven = Math.floor( spherical.phi / angleStep ) % 2 === 0;\n\t\t\tconst isBlack = thetaEven === phiEven;\n\t\t\ttarget.set( isBlack ? 0 : 0xffffff ).multiplyScalar( 1.5 );\n\t\t\ttarget.multiplyScalar( skyIntensity );\n\n\t\t} else if ( skyMode === 'sun' ) {\n\n\t\t\tnormal0.setScalar( 1 ).normalize();\n\n\t\t\tlet value = Math.max( 0.0, direction.dot( normal0 ) + 1.0 ) / 2.0;\n\t\t\tvalue *= value;\n\t\t\ttarget.r = THREE.MathUtils.lerp( 0.01, 0.5, value );\n\t\t\ttarget.g = THREE.MathUtils.lerp( 0.01, 0.7, value );\n\t\t\ttarget.b = THREE.MathUtils.lerp( 0.01, 1.0, value );\n\n\t\t\tif ( value > 0.95 ) {\n\n\t\t\t\tlet value2 = ( value - 0.95 ) / 0.05;\n\t\t\t\tvalue2 *= value2;\n\t\t\t\ttarget.r = THREE.MathUtils.lerp( 0.5, 10.0, value2 );\n\t\t\t\ttarget.g = THREE.MathUtils.lerp( 0.7, 10.0, value2 );\n\t\t\t\ttarget.b = THREE.MathUtils.lerp( 1.0, 10.0, value2 );\n\n\t\t\t}\n\n\t\t\ttarget.multiplyScalar( skyIntensity );\n\n\t\t} else {\n\n\t\t\tconst value = ( direction.y + 0.5 ) / 2.0;\n\t\t\ttarget.r = THREE.MathUtils.lerp( 1.0, 0.5, value );\n\t\t\ttarget.g = THREE.MathUtils.lerp( 1.0, 0.7, value );\n\t\t\ttarget.b = THREE.MathUtils.lerp( 1.0, 1.0, value );\n\t\t\ttarget.multiplyScalar( skyIntensity );\n\n\t\t}\n\n\t}\n\n}\n\nfunction toHumanReadableTime( ms ) {\n\n\tms = ms || 0;\n\n\tlet seconds = ms * 1e-3;\n\tconst minutes = Math.floor( seconds / 60 );\n\tseconds = seconds - minutes * 60;\n\n\tconst minutesString = ( minutes < 10 ? '0' : '' ) + minutes;\n\tconst secondsString = ( seconds < 10 ? '0' : '' ) + seconds.toFixed( 3 );\n\n\treturn `${ minutesString }m ${ secondsString }s`;\n\n}\n\nfunction render() {\n\n\trequestAnimationFrame( render );\n\n\tfor ( const key in models ) {\n\n\t\tif ( models[ key ] ) {\n\n\t\t\tmodels[ key ].mesh.visible = false;\n\n\t\t}\n\n\t}\n\n\t// select the model and initialize set the 0 material with the user settings\n\tif ( models[ params.model ] ) {\n\n\t\tconst model = models[ params.model ];\n\t\tmodel.mesh.visible = true;\n\t\tmesh = model.mesh;\n\t\tmaterials = model.materials;\n\t\tfloorMesh.position.y = model.floorHeight;\n\n\t\t// initialize ior and transmission not present on materials already\n\t\tmaterials.forEach( m => {\n\n\t\t\tif ( m.ior === undefined ) m.ior = 1;\n\t\t\tif ( m.transmission === undefined ) m.transmission = 0.0;\n\n\t\t} );\n\n\t\tconst material = materials[ 0 ];\n\t\tmaterial.color.set( params.material.color ).convertSRGBToLinear();\n\t\tmaterial.emissive.set( params.material.emissive ).convertSRGBToLinear();\n\t\tmaterial.emissiveIntensity = parseFloat( params.material.emissiveIntensity );\n\t\tmaterial.ior = parseFloat( params.material.ior );\n\t\tmaterial.metalness = parseFloat( params.material.metalness );\n\t\tmaterial.transmission = parseFloat( params.material.transmission );\n\n\t\t// use a \"perceptualRoughness\" concept when interpreting user input\n\t\t// https://google.github.io/filament/Filament.html#materialsystem/standardmodelsummary\n\t\tmaterial.roughness = Math.pow( parseFloat( params.material.roughness ), 2.0 );\n\n\t\t// adjust the position of the area light before rendering\n\t\tswitch ( params.light.position ) {\n\n\t\t\tcase 'Below':\n\t\t\t\tlightMesh.rotation.set( - Math.PI / 2, 0, 0 );\n\t\t\t\tlightMesh.position.set( 0, model.floorHeight + 1e-3, 0 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'Above':\n\t\t\t\tlightMesh.rotation.set( Math.PI / 2, 0, 0 );\n\t\t\t\tlightMesh.position.set( 0, 2 - 1e-3, 0 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlightMesh.position.set( 2, 2, 2 );\n\t\t\t\tlightMesh.lookAt( 0, 0, 0 );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} else {\n\n\t\tmesh = null;\n\t\tmaterials = null;\n\t\tfloorMesh.position.y = 0;\n\n\t}\n\n\t// Fade the path traced image in after the user stops moving the camera\n\tlet fade = 0;\n\tif ( delay > FADE_DELAY ) {\n\n\t\tfade = Math.min( ( delay - FADE_DELAY ) / ( DELAY_TIME - FADE_DELAY ), 1.0 );\n\n\t}\n\n\t// update the scan line\n\tscanLineElement.style.bottom = `${ scanLinePercent }%`;\n\tif ( params.resolution.stretchImage ) {\n\n\t\tscanLineElement.style.borderBottomWidth = `${ Math.ceil( 1 / params.resolution.resolutionScale ) }px`;\n\n\t} else {\n\n\t\tscanLineElement.style.borderBottomWidth = '1px';\n\n\t}\n\n\t// render the scene\n\trenderer.render( scene, camera );\n\trenderer.autoClear = false;\n\n\t// overlay the path traced image\n\tfsQuad.material.map = dataTexture;\n\tfsQuad.material.opacity = fade;\n\tfsQuad.render( renderer );\n\trenderer.autoClear = true;\n\n\t// run the path tracing\n\t// world matrices are up to date because of the above render\n\tif ( mesh && ! params.pathTracing.pause ) {\n\n\t\ttask.next();\n\n\t}\n\n\t// force the data texture to upload now that it's changed but do it after render so the\n\t// upload happens asynchronously and will be ready next frame.\n\tdataTexture.needsUpdate = true;\n\trenderer.compile( fsQuad._mesh );\n\n\t// count down the fade\n\tif ( delay < DELAY_TIME ) {\n\n\t\tdelay += clock.getDelta() * 1e3;\n\n\t}\n\n\toutputContainer.innerText =\n\t\t`completed samples : ${ samples }\\n` +\n\t\t`computation time  : ${ toHumanReadableTime( computationTime ) }\\n` +\n\t\t`elapsed time      : ${ toHumanReadableTime( performance.now() - renderStartTime ) }`;\n\n}\n\n"],"names":["$9afdfc7e12e6b8a1$var$tempVector","Vector3","$9afdfc7e12e6b8a1$var$tempVector1","$hGT0Q","$9afdfc7e12e6b8a1$var$tempVector2","$9afdfc7e12e6b8a1$export$83cca5794a482c0","$9afdfc7e12e6b8a1$export$ecd5dd9a6150ab1f","cosine","iorRatio","f0","Math","pow","$9afdfc7e12e6b8a1$export$cbf90d93e26e479","$9afdfc7e12e6b8a1$export$4d7afc9e2770a1ec","normal","targetMatrix","abs","x","set","crossVectors","normalize","makeBasis","$9afdfc7e12e6b8a1$export$5fef809e32451cd0","a","b","target","addVectors","$9afdfc7e12e6b8a1$export$c4618275c5af62bc","direction","surfaceNormal","geometryNormal","dot","$2304bcb050a1df77$var$_V","$2304bcb050a1df77$var$_T1","$2304bcb050a1df77$var$_T2","$2304bcb050a1df77$var$_N","$2304bcb050a1df77$var$_Z_VECTOR","$2304bcb050a1df77$var$M_PI","PI","$2304bcb050a1df77$var$ggxLamda","theta","roughness","tanTheta","tan","tanTheta2","alpha2","sqrt","$2304bcb050a1df77$export$fea7bf0f85d89c60","halfVector","a2","cosTheta","z","cosTheta4","acos","$2304bcb050a1df77$export$4a51b6e1d8ff04e7","wi","incidentTheta","D","G1","$2304bcb050a1df77$export$8dfbefd49188d375","max","$df428eaf15eac279$var$tempDir","$df428eaf15eac279$var$halfVector","$df428eaf15eac279$var$tempColor","Color","$df428eaf15eac279$var$whiteColor","$df428eaf15eac279$var$specularDirection","wo","hit","material","lightDirection","filteredRoughness","filteredSurfaceRoughness","incidentDir","roughnessX","roughnessY","random1","random2","V","y","T1","T2","r","phi","P1","cos","P2","sin","multiplyScalar","N","addScaledVector","copy","$2304bcb050a1df77$export$e0e6fc83417c4e49","random","reflect","$df428eaf15eac279$var$specularColor","colorTarget","metalness","ior","frontFace","G","scatterTheta","$2304bcb050a1df77$export$55874a84998f17b","F","min","lerpColors","color","MathUtils","lerp","$df428eaf15eac279$var$transmissionDirection","ratio","dir","norm","lengthSq","add","$9afdfc7e12e6b8a1$export$f49311db2be090a0","randomDirection","$df428eaf15eac279$export$b238c09be3ebd1a7","transmission","sinTheta","reflectance","spdf","dpdf","tpdf","$df428eaf15eac279$var$specularPDF","$df428eaf15eac279$var$diffusePDF","transSpecularProb","diffSpecularProb","$df428eaf15eac279$export$f582f72c7e832743","targetColor","g","$df428eaf15eac279$var$transmissionColor","$df428eaf15eac279$var$diffuseColor","$df428eaf15eac279$export$98d4fd8b0924db66","sampleInfo","specularProb","$df428eaf15eac279$var$diffuseDirection","pdf","$58d5a2966575fcc2$var$scene","$58d5a2966575fcc2$var$camera","$58d5a2966575fcc2$var$renderer","$58d5a2966575fcc2$var$light","$58d5a2966575fcc2$var$clock","$58d5a2966575fcc2$var$fsQuad","$58d5a2966575fcc2$var$controls","$58d5a2966575fcc2$var$dataTexture","$58d5a2966575fcc2$var$samples","$58d5a2966575fcc2$var$task","$58d5a2966575fcc2$var$delay","$58d5a2966575fcc2$var$scanLinePercent","$58d5a2966575fcc2$var$scanLineElement","$58d5a2966575fcc2$var$containerElement","$58d5a2966575fcc2$var$outputContainer","$58d5a2966575fcc2$var$renderStartTime","$58d5a2966575fcc2$var$computationTime","$58d5a2966575fcc2$var$mesh","$58d5a2966575fcc2$var$materials","$58d5a2966575fcc2$var$lightMesh","$58d5a2966575fcc2$var$floorMesh","Mesh","prototype","raycast","$aBPXg","acceleratedRaycast","BufferGeometry","computeBoundsTree","disposeBoundsTree","$58d5a2966575fcc2$var$triangle","Triangle","$58d5a2966575fcc2$var$normal0","$58d5a2966575fcc2$var$normal1","$58d5a2966575fcc2$var$normal2","$58d5a2966575fcc2$var$barycoord","$58d5a2966575fcc2$var$spherical","Spherical","$58d5a2966575fcc2$var$normalBasis","Matrix4","$58d5a2966575fcc2$var$invBasis","$58d5a2966575fcc2$var$localDirection","$58d5a2966575fcc2$var$tempColor","$58d5a2966575fcc2$var$tempVector","$58d5a2966575fcc2$var$models","$58d5a2966575fcc2$var$params","model","resolution","resolutionScale","smoothImageScaling","stretchImage","pathTracing","pause","displayScanLine","antialiasing","bounces","filterGlossyFactor","smoothNormals","directLightSampling","emissive","emissiveIntensity","floor","enable","width","height","light","position","intensity","environment","skyMode","skyIntensity","$58d5a2966575fcc2$var$mergeMeshes","meshes","cloneGeometry","transformedGeometry","materials","i","l","length","mesh","originalGeometry","geometry","geom","clone","updateMatrixWorld","applyMatrix4","matrixWorld","vertexCount","attributes","count","materialIndexArray","Uint8Array","fill","setAttribute","BufferAttribute","push","$7N5zk","mergeBufferGeometries","$58d5a2966575fcc2$var$onResize","resizeDataTexture","w","h","image","dispose","DataTexture","Float32Array","RGBAFormat","FloatType","$58d5a2966575fcc2$var$resetImage","aspect","window","innerWidth","innerHeight","updateProjectionMatrix","dpr","devicePixelRatio","style","setSize","setPixelRatio","domElement","imageRendering","data","needsUpdate","parseInt","parseFloat","radianceColor","throughputColor","ssPoint","Vector2","rayStack","Array","map","Ray","lightForward","transformDirection","lightWidth","scale","lightHeight","raycaster","Raycaster","firstHitOnly","seedRay","lastStartTime","performance","now","visibility","side","DoubleSide","forEach","randomOffsetX","randomOffsetY","antiAliasIndex","setFromCamera","ray","origin","near","pathTrace","index","delta","expandHitInformation","accumulatedRoughness","object","posAttr","normalAttr","materialAttr","materialIndex","face","point","fromBufferAttribute","c","getBarycoord","setScalar","hitFrontFace","getX","currentRay","lastPdf","objects","intersectObjects","sampleSkyBox","multiply","lightColor","weight","distance","nextRay","invert","subVectors","lightArea","lightPdf","distanceToSquared","shadowHit","misWeight","isBelowSurface","setFromVector3","angleStep","isBlack","value","value2","$58d5a2966575fcc2$var$runPathTracingLoop","visible","$58d5a2966575fcc2$var$toHumanReadableTime","ms","seconds","minutes","toFixed","WebGLRenderer","antialias","setClearColor","outputEncoding","sRGBEncoding","document","createElement","inset","margin","zIndex","body","appendChild","borderBottom","getElementById","$hwk6U","FullScreenQuad","MeshBasicMaterial","transparent","Scene","PerspectiveCamera","far","HemisphereLight","PlaneBufferGeometry","lookAt","MeshStandardMaterial","rotation","$W2bOH","OrbitControls","addEventListener","sphereMesh","SphereBufferGeometry","merged","strategy","SAH","maxLeafTris","floorHeight","planeGeom","leftWall","rightWall","backWall","ceiling","box","BoxBufferGeometry","box2","$4EHgc","GLTFLoader","load","gltf","scene","traverse","isMesh","name","center","rotateX","quaternion","identity","generator","$3C1cw","GenerateMeshBVHWorker","generate","then","bvh","boundingBox","boundsTree","terminate","setMeshoptDecoder","$c0AwW","MeshoptDecoder","originalMesh","children","newGeometry","ogPosAttr","ogNormAttr","normAttr","vec","setXYZ","setIndex","computeBoundingBox","CENTER","Clock","gui","$4Q0VG","GUI","Object","keys","onChange","resolutionFolder","addFolder","open","pathTracingFolder","v","materialFolder","addColor","floorFolder","lightFolder","envFolder","$58d5a2966575fcc2$var$init","$58d5a2966575fcc2$var$render","requestAnimationFrame","key","m","undefined","convertSRGBToLinear","fade","bottom","borderBottomWidth","ceil","render","autoClear","opacity","next","compile","_mesh","getDelta","innerText"],"version":3,"file":"cpuPathTracing.30811637.js.map"}